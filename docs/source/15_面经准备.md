+ GET和POST的区别

```
最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
```

+ POST和PUT的区别

```
PUT是等幂的，会用新的覆盖旧的。需要提交全部的信息。
```

+ SYN FLOOD是什么，如何防御？

```
	除了定制TCP/IP协议栈之外，还有一种常见做法是TCP首包丢弃方案，利用TCP协议的重传机制识别正常用户和攻击报文。当防御设备接到一个IP地址的SYN报文后，简单比对该IP是否存在于白名单中，存在则转发到后端。如不存在于白名单中，检查是否是该IP在一定时间段内的首次SYN报文，不是则检查是否重传报文，是重传则转发并加入白名单，不是则丢弃并加入黑名单。是首次SYN报文则丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。
	首包丢弃方案对用户体验会略有影响，因为丢弃首包重传会增大业务的响应时间，有鉴于此发展出了一种更优的TCP Proxy方案。所有的SYN数据报文由清洗设备接受，按照SYN Cookie方案处理。和设备成功建立了TCP三次握手的IP地址被判定为合法用户加入白名单，由设备伪装真实客户端IP地址再与真实服务器完成三次握手，随后转发数据。而指定时间内没有和设备完成三次握手的IP地址，被判定为恶意IP地址屏蔽一定时间。除了SYN Cookie结合TCP Proxy外，清洗设备还具备多种畸形TCP标志位数据包探测的能力，通过对SYN报文返回非预期应答测试客户端反应的方式来鉴别正常访问和恶意行为。
```

+ 一个进程中线程共享的资源

```
共享资源：
1. 堆，如new出来的资源
2. 全局变量和静态变量（数据段）
3. 代码段
独享的资源：
1. 栈（栈段）
2. 寄存器
```

+ 同步与异步的区别，阻塞和非阻塞的区别

```
同步异步指调用的过程，而阻塞非阻塞表示进程是否会从busy状态变为wait的状态，线程是否会被挂起。
```

+ 编程语言中闭包

```
1: function createCounter() {
2:  let counter = 0
3:  const myFunction = function () {
4:    counter = counter + 1
5:    return counter
6:  }
7:  return myFunction
8: }
9:  const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
//输出1，2，3
13: console.log('example increment', c1, c2, c3)

```

```
函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。

javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。
出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。那就是使用闭包函数。
```



+ 面向对象三大特征

```
1. 封装
2. 继承
3. 多态
```



+ Memcache与Redis的区别

```
1. 存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能 超过内存大小。 Redis 有部份存在硬盘上，这样能保证数据的持久性。
2. 数据支持类型 Memcache 对数据类型支持相对简单。 Redis 有复杂的数据类型。 
3. 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议 不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话， 会浪费一定的时间去移动和请求。
```

+ 缓存穿透、缓存击穿、缓存雪崩

```
缓存穿透，是指查询一个数据库一定不存在的数据。
想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。
——————————————————————————————————————————————————————
缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。
———————————————————————————————————————————————————————
缓存雪崩，是指在某一个时间段，缓存集中过期失效。
产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。
```

+ CPU调度算法

```
1. 先来先服务算法
2. 短作业优先算法
3. 按时间片来轮询调度
4. 按照优先级来进行调度
```

+ http与https区别

```
1. http是明文传输，https是密文传输
2. https传输效率略低
```

+ 协程

```
 协程，英文Coroutines，是一种比【线程】更加【轻量级】的存在。
 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。
 【协程】不是被操作系统【内核】所管理的，而完全是由【程序】所控制（也就是在【用户态】执行）
 应用：
 1. 无限列表，yeild
 2. 管道
 3. 并发
```

+ c++智能指针

```
对于一个大型项目，在某一处创建的对象，可能并不会在对应作用域中释放，而是等到某些事件发生，异常处理等情况下才会去销毁对象，对于这样的问题往往是很难排查出来的。所以，有必要引用一种机制来负责指针的自动销毁。而不是由程序员本身去手动销毁。智能指针恰恰就是这样的一种机制。

给引用的指针增加了一个计数的功能，这样就能随时知道是否还存在引用了
```

+ 多核CPU如何保证缓存数据的一致性

```
	多个CPU从主内存读取了同一份数据到各自的高速缓存（L1、L2或其它），当其中一个CPU修改了数据往主内存同步时，其它CPU会通过总线嗅探机制感知到数据的变化，从而让自己缓存的数据无效，当感知到变化的CPU再往主内存写数据时，会先从主内存读取一份计算再回写。

```

+ 已知前序和中序，求后序？已知前序和后序，求形态的个数？
+ 线程与进程

```
进程是系统进行资源调度和分配的的基本单位，实现了操作系统的并发。
线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。

```

+ 硬链接与软链接的区别

```
若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。
若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。
```

